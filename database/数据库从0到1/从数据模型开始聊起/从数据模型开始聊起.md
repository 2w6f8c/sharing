# 从数据模型开始聊起    
- [从数据模型开始聊起](#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B%E8%81%8A%E8%B5%B7)
  - [介绍](#%E4%BB%8B%E7%BB%8D)
    - [关系模型](#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B)
    - [网络模型](#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
    - [文档模型](#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B)
      - [层次模型](#%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B)
    - [图模型](#%E5%9B%BE%E6%A8%A1%E5%9E%8B)
    - [时序数据模型](#%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B)
  - [比较和关联](#%E6%AF%94%E8%BE%83%E5%92%8C%E5%85%B3%E8%81%94)

## 介绍
**全文结构及内容大量参考《[Designing Data-Intensive Application][DDIA]》的第二章数据模型与查询语言，重新组织了一些结构，带有部分自己的看法与介绍，主要在分享时阐述与讲解。**

[DDIA]: http://dataintensive.net/

[数据模型][data_model]（Data Model）是数据特征的抽象。

数据模型这个东西可能会是软件开发中最重要的一个部分了，因为他们的影响非常的深远，不仅仅影响着软件编写方式，而且影响着我们的**解决问题的思路**

数据模型所描述的主要内容包括三个部分：
- 数据结构
- 数据操作
- 数据约束

根据其不同的应用层次，我们将数据模型**主要**分为以下[三种类型][three_type]：
- 概念数据模型

  用于描述客观世界的模型，一般要具有较强的语义表达能力，并且简单，清晰，易于用户理解。  
  常见的 [E-R模型][er_model]，面向对象模型等。

- **[逻辑数据模型](#逻辑数据模型)**
  
  对概念数据模型的进一步细化，主要是面向数据库系统的模型，是具体的 DBMS 所支持的数据模型。  
  常见的关系模型，文档模型，网络模型，图数据模型等。

- 物理数据模型
  
  数据在计算机上的物理表示的模型，描述了数据在存储介质上的组织结构。  
  DBMS 为了保证其独立性与可移植性，大部分物理数据模型的实现工作由系统自动完成，而设计者只设计索引等特殊结构。

[data_model]: https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B "数据模型 百度百科"
[three_type]: https://blog.csdn.net/gdj0001/article/details/80137496 "概念数据模型、逻辑数据模型、物理数据模型 csdn博客"
[er_model]: https://baike.baidu.com/item/E-R%E6%A8%A1%E5%9E%8B "E-R模型 百度百科"

引用书中的内容来更详细的描述层次的数据模型。

> 从应用的角度来看，多数应用使用层层叠加的数据模型构建。   
> 对于每层数据模型的关键是：**他是如何用低一层的数据模型来表示的？**
> 例如：
> 1. 作为一个应用的开发人员，你观察现实世界（里面有人员，组织货物，行为等等），并采用对象或数据结构，以及操控哪些数据结构的 API 来进行建模。那些结构通常是特定与应用程序的。
> 2. 当要存储那些数据结构时，你可以利用数据模型来表示它们，如 JSON 或 XML 文档，关系数据库中的表，或图模型。
> 3. 数据库软件的工程师选定如何以内存、磁盘或网络上的字节来表示JSON/XML/关系/图数据。这类表示形式使数据有可能以各种方式来查询，搜索，操纵和处理。
> 4. 在更低的层次上，硬件工程师已经想出了使用电流，光脉冲，磁场或者其他东西来表示字节的方法。

对于一个复杂的应用程序来说，层次会比上面描述的更加复杂，更多的中间层次会被添加在应用的内部（例如基于API的API，开发过程的）。不过基本的思想仍然是一样的：每个层都通过提供一个明确的数据模型来隐藏更低层次的复杂性。（到这里其实会让我想到软件开发过程中经常讨论到的一句名言，“计算机科学领域的任何问题都可以通过增加一个中间层来解决”，Any problem  in computer science can be solved by anther layer of indirection。这句话讲道理概括了计算机系统软件体系结构设计要点，在我们的系统中被各种各样的应用。操作系统的体系结构设计啊，web开发中的mvc啊，负载均衡的时候加的代理啊，一致性哈希解决负载不均衡的虚拟层啊，等等等等）。

所谓“数据库”，是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。你的字典是一个小数据库，图书馆也是一个数据库。而我们研发同学经常会讨论的数据库，应该是所谓的`数据库管理系统（DBMS）`。

本次分享将从一些用于数据存储和查询的通用数据模型开始聊起，包含相关数据库的应用及场景的介绍，穿插一些数据库发展的内容。


 ## 逻辑数据模型

**本节中的介绍内容大多摘自DDIA，主要是概念内容的概括，做了一部分结构的调整，分享时不详细介绍，但是会通过[比较和关联](#比较和关联)部分来进行探讨。**

多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，[网络模型](#网络模型)和[层次模型](#层次模型)曾是主要的选择，但[关系模型](#关系模型)随后占据了主导地位。对象数据库在20世纪80年代末和90年代初来了又去。XML数据库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续。  

随着电脑越来越强大和互联，它们开始用于日益多样化的目的。关系数据库非常成功地被推广到业务数据处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。

###  关系模型 
从数据库开始发展到现在，最著名的数据模型可能就是关系数据模型了，它基于 Edgar Codd 在1970年提出的关系模型，阐述在论文《[大型共享数据银行的关系模型][Codd_1970_A_relational_model]》中。数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。
 
起初关系模型只是一个理论性的提议，但是随着发展，关系数据库已经称霸了将近30年。  

关系数据库起源于商业数据处理，在20世纪60年代和70年代用大型计算机来执行。从今天的角度来看，那些用例显得很平常：典型的事务处理（销售或银行交易，航空公司预订，库存管理信息记录在库）和批处理（客户发票，工资单，报告）。

当时的其他数据库迫使应用程序开发人员必须考虑数据库内部的数据表示形式。关系模型致力于将上述实现细节隐藏在更简洁的接口之后。

多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，网络模型和分层模型曾是主要的选择，但关系模型随后占据了主导地位。对象数据库在20世纪80年代末和90年代初来了又去。XML数据库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续。

随着电脑越来越强大和互联，它们开始用于日益多样化的目的。关系数据库非常成功地被推广到业务数据处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系数据库来提供支持，无论是在线发布，讨论，社交网络，电子商务，游戏，软件即服务生产力应用程序等等内容。

[Codd_1970_A_relational_model]: https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf


### 网络模型

网络模型由一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的数据库商实现；它也被称为CODASYL模型。

CODASYL模型是层次模型的推广。在层次模型的树结构中，每条记录只有一个父节点；在网络模式中，每条记录可能有多个父节点。例如，“Greater Seattle Area”地区可能是一条记录，每个居住在该地区的用户都可以与之相关联。这允许对多对一和多对多的关系进行建模。  

网络模型中记录之间的链接不是外键，而更像编程语言中的指针（同时仍然存储在磁盘上）。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为**访问路径（access path）**。  

最简单的情况下，访问路径类似遍历链表：从列表头开始，每次查看一条记录，直到找到所需的记录。但在多对多关系的情况中，数条不同的路径可以到达相同的记录，网络模型的程序员必须跟踪这些不同的访问路径。

CODASYL中的查询是通过利用遍历记录列和跟随访问路径表在数据库中移动游标来执行的。如果记录有多个父结点（即多个来自其他记录的传入指针），则应用程序代码必须跟踪所有的各种关系。甚至CODASYL委员会成员也承认，这就像在n维数据空间中进行导航。

尽管手动选择访问路径够能最有效地利用20世纪70年代非常有限的硬件功能（如磁带驱动器，其搜索速度非常慢），但这使得查询和更新数据库的代码变得复杂不灵活。无论是分层还是网络模型，如果你没有所需数据的路径，就会陷入困境。你可以改变访问路径，但是必须浏览大量手写数据库查询代码，并重写来处理新的访问路径。更改应用程序的数据模型是很难的。

### 文档模型

搜索数据模型几乎没有提到文档模型的说法，书中将这种基于 **JSON** 或 **XML** 等文档状数据格式存储的方式称之为文档模式。

它提供了更多的架构灵活性。文档数据库有时称为**无模式（schemaless）**，但其实代码通常假定了某种结构————即存在隐式模式，但不由数据库强制执行。一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）。


#### 层次模型

在多对多的关系和连接已常规用在关系数据库时，文档数据库和NoSQL重启了辩论：如何最好地在数据库中表示多对多关系。那场辩论可比NoSQL古老得多，事实上，最早可以追溯到计算机化数据库系统。

20世纪70年代最受欢迎的业务数据处理数据库是IBM的信息管理系统（IMS），最初是为了阿波罗太空计划的库存管理而开发的，并于1968年有了首次商业发布。目前它仍在使用和维护，运行在IBM大型机的OS/390上。

IMS的设计中使用了一个相当简单的数据模型，称为层次模型（hierarchical model），它与文档数据库使用的JSON模型有一些惊人的相似之处。它将所有数据表示为嵌套在记录中的记录树，这很像JSON结构。

同文档数据库一样，IMS能良好处理一对多的关系，但是很难应对多对多的关系，并且不支持连接。开发人员必须决定是否复制（非规范化）数据或手动解决从一个记录到另一个记录的引用。这些二十世纪六七十年代的问题与现在开发人员遇到的文档数据库问题非常相似。

那时人们提出了各种不同的解决方案来解决层次模型的局限性。其中最突出的两个是关系模型（relational model）（它变成了SQL，统治了世界）和网络模型（network model）（最初很受关注，但最终变得冷门）。这两个阵营之间的“大辩论”在70年代持续了很久时间。

### 图模型

如我们之前所见，多对多关系是不同数据模型之间具有区别性的重要特征。如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。

但是，要是多对多关系在你的数据中很常见呢？关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。

一个图由两种对象组成：顶点（vertices）（也称为节点（nodes） 或实体（entities）），和边（edges）（ 也称为关系（relationships）或弧 （arcs） ）。多种数据可以被建模为一个图形。典型的例子包括：
* 社交图谱
  
    顶点是人，边指示哪些人彼此认识。
* 网络图谱
 
    顶点是网页，边缘表示指向其他页面的HTML链接。
* 公路或铁路网络
  
    顶点是交叉路口，边线代表它们之间的道路或铁路线。

可以将那些众所周知的算法运用到这些图上：例如，汽车导航系统搜索道路网络中两点之间的最短路径，PageRank可以用在网络图上来确定网页的流行程度，从而确定该网页在搜索结果中的排名。

在刚刚给出的例子中，图中的所有顶点代表了相同类型的事物（人，网页或交叉路口）。不过，图并不局限于这样的同类数据：同样强大地是，图提供了一种一致的方式，用来在单个数据存储中存储完全不同类型的对象。例如，Facebook维护一个包含许多不同类型的顶点和边的单个图：顶点表示人，地点，事件，签到和用户的评论;边缘表示哪些人是彼此的朋友，哪个签到发生在何处，谁评论了哪条消息，谁参与了哪个事件，等等。

### 时序数据模型

似乎直接搜索时序数据模型，是得不到和数据库方面相关的数据模型的介绍的，这里这样将其提出，也是为了与当前业界非常流行的时序数据库相匹配。

时序数据主要就是指按时间维度产生和索引的一些数据。 

>对时序数据进行建模的话，会包含三个重要部分，分别是：主体，时间点和测量值。套用这套模型，你会发现你在日常工作生活中，无时无刻不在接触着这类数据。
> - 如果你是一个股民，某只股票的股价就是一类时序数据，其记录着每个时间点该股票的股价。
> - 如果你是一个运维人员，监控数据是一类时序数据，例如对于机器的CPU的监控数据，就是记录着每个时间点机器上CPU的实际消耗值。 

因为有着对大量时序数据的存储和分析需求，为了解决传统关系型数据库在时序数据存储和分析上的不足和缺陷，一系列时序数据库产品便被创造出来。

能力水平有限，这里我就不细细的全部说明。
主要内容多参考自知乎专栏[NoSQL技术解析][NoSQL技术解析] 中的
《[时间序列数据的存储和计算 - 概述][时间序列数据的存储和计算 - 概述]》等系列文章。



[NoSQL技术解析]: https://zhuanlan.zhihu.com/nosql
[时间序列数据的存储和计算 - 概述]: https://zhuanlan.zhihu.com/p/32709932


## 比较和关联

接下来的内容会以一个简历（一个LinkedIn简介）为例，来回穿插数据模型的内容。